<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数据纹理读写</title>
</head>

<body>
    <div id="cesiumContainer"></div>
    <canvas id="outputCanvas"></canvas>
    <div id="button-container">
        <button onclick="renderToPostStage()">RenderToPostStage</button>
    </div>

    <!-- base -->
    <script src="https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
    <link rel="stylesheet" href="./common/base.css">
    <script src="../../Build/CesiumUnminified/Cesium.js"></script>
    <script src="common/methods.js"></script>
    <!-- base end -->

    <script>
        const viewer = new Cesium.Viewer("cesiumContainer");

        const rangePositions = [
            new Cesium.Cartesian3(-2712542.2347164466, 4291905.330727653, 3847403.3661934948),
            new Cesium.Cartesian3(-2727357.3523860485, 4281552.533897097, 3848462.905365525),
            new Cesium.Cartesian3(-2732460.8527903804, 4288118.765704473, 3837584.939264291),
            new Cesium.Cartesian3(-2716256.053677195, 4298864.491220042, 3837072.97189279),
        ]

        if (rangePositions[0] !== rangePositions.at(-1)) {
            rangePositions.push(rangePositions[0]);
        }

        const rangeEntity = viewer.entities.add({
            polyline: {
                positions: rangePositions,
                material: Cesium.Color.RED
            }
        })
        viewer.flyTo(rangeEntity, {
            duration: 1
        })

        function renderToPostStage() {
            const getRangeCenter = (positions) => {
                let center = new Cesium.Cartesian3();
                positions.forEach(element => {
                    center = Cesium.Cartesian3.add(center, element, new Cesium.Cartesian3());
                });
                center = Cesium.Cartesian3.divideByScalar(center, 1 / positions.length, new Cesium.Cartesian3());
                return center;
            }

            const getRangeTexture = (positions) => {
                let result = [], center = new Cesium.Cartesian3();
                positions.forEach(element => {
                    result = result.concat([element.x, element.y, element.z])
                });

                const rangePositionECTexture = new Cesium.Texture({
                    context: viewer.scene.context,
                    pixelFormat: Cesium.PixelFormat.RGB,
                    pixelDatatype: Cesium.PixelDatatype.FLOAT,
                    source: {
                        arrayBufferView: new Float32Array(result),
                        width: positions.length,
                        height: 1,
                    },
                    flipY: false,
                    sampler: {
                        // 使用NEAREST过滤，避免插值
                        minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
                        magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST,
                        // 存储数据的纹理，通常CLAMP_TO_EDGE而不是REPEAT，避免数据重复存储
                        wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
                        wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE
                    }
                })

                return rangePositionECTexture;
            }

            const getPositionWCByDepth_GLSL = () => {
                return `
                    vec4 getPositionWCByDepth(sampler2D depthTexture, vec2 texCoord) {
                        vec4 positionEC = czm_windowToEyeCoordinates(
                            gl_FragCoord.xy, 
                            czm_unpackDepth(texture(depthTexture, texCoord))
                        );
                        positionEC = positionEC / positionEC.w;
                        vec4 positionWC = czm_inverseView * positionEC;
                        positionWC = positionWC / positionWC.w;
                        return positionWC;
                    }
                `
            }

            const rangePositionECTexture = getRangeTexture(rangePositions);
            const inverseENU = Cesium.Matrix4.inverse(
                Cesium.Transforms.eastNorthUpToFixedFrame(getRangeCenter(rangePositions)),
                new Cesium.Matrix4()
            );
            const postProcessStages = viewer.scene.postProcessStages.add(
                new Cesium.PostProcessStage({
                    name: 'rangeTexture',
                    fragmentShader: `
                        uniform sampler2D colorTexture;
                        uniform sampler2D depthTexture;
                        in vec2 v_textureCoordinates;

                        
                        uniform sampler2D u_rangeTexture; // 范围纹理
                        uniform mat4 u_inverseENU;  // ENU坐标系的逆矩阵

                        ${getPositionWCByDepth_GLSL()}

                        void main() {
                            vec4 originalColor = texture(colorTexture, v_textureCoordinates);
                            vec4 positionWC = getPositionWCByDepth(depthTexture, v_textureCoordinates);
                            
                            const int rangeLength = ${rangePositions.length};
                            vec3 rangePositions[rangeLength];
                            // 读取纹理中的数据
                            for (int i = 0; i < rangeLength; i++) {
                                float xOffset = float(i) + 0.5;
                                float perVal = 1.0 / float(rangeLength);

                                rangePositions[i] = texture(
                                    u_rangeTexture, 
                                    vec2(perVal * xOffset, 0.5)
                                ).xyz;
                            }
                        
                            // 测试数据读取与原始数据是否一致
                            if (
                                rangePositions[0].x == -2712542.2347164466 && 
                                rangePositions[0].x == -2712542.2347164466 && 
                                rangePositions[0].y == 4291905.330727653 && 
                                rangePositions[0].z == 3847403.3661934948 && 

                                rangePositions[1].x == -2727357.3523860485 && 
                                rangePositions[1].y == 4281552.533897097 && 
                                rangePositions[1].z == 3848462.905365525 && 

                                rangePositions[2].x == -2732460.8527903804 && 
                                rangePositions[2].y == 4288118.765704473 && 
                                rangePositions[2].z == 3837584.939264291 &&

                                rangePositions[3].x == -2716256.053677195 &&
                                rangePositions[3].y == 4298864.491220042 && 
                                rangePositions[3].z == 3837072.97189279
                            ) {
                                out_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
                            } else {
                                out_FragColor = vec4(originalColor.rgb, 1.0);
                            }
                        }
                    `,
                    uniforms: {
                        u_rangeTexture: () => rangePositionECTexture,
                        u_inverseENU: () => inverseENU
                    }
                })
            )

        }
        
        // 拾取
        // const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
        // handler.setInputAction(function (click) {
        //     const position = viewer.scene.pickPosition(click.position);
        //     if (Cesium.defined(position)) {
        //         console.log(position);
        //     }
        // }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    </script>
</body>

</html>