<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数据纹理读写</title>
</head>

<body>
    <div id="cesiumContainer"></div>
    <canvas id="outputCanvas"></canvas>
    <div id="button-container">
        <button onclick="renderToPostStage()">RenderToPostStage</button>
    </div>

    <!-- base -->
    <script src="https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
    <link rel="stylesheet" href="./common/base.css">
    <script src="../../Build/CesiumUnminified/Cesium.js"></script>
    <script src="common/methods.js"></script>
    <!-- base end -->

    <script>
        const viewer = new Cesium.Viewer("cesiumContainer");

        const rangePositions = [
            new Cesium.Cartesian3(-2712542.2347164466, 4291905.330727653, 3847403.3661934948),
            new Cesium.Cartesian3(-2727357.3523860485, 4281552.533897097, 3848462.905365525),
            new Cesium.Cartesian3(-2732460.8527903804, 4288118.765704473, 3837584.939264291),
            new Cesium.Cartesian3(-2716256.053677195, 4298864.491220042, 3837072.97189279),
        ]

        if (rangePositions[0] !== rangePositions.at(-1)) {
            rangePositions.push(rangePositions[0]);
        }

        const rangeEntity = viewer.entities.add({
            polyline: {
                positions: rangePositions,
                material: Cesium.Color.RED
            }
        })
        viewer.flyTo(rangeEntity, {
            duration: 1
        })

        function renderToPostStage() {
            const getRangeCenter = (positions) => {
                let center = new Cesium.Cartesian3();
                positions.forEach(element => {
                    center = Cesium.Cartesian3.add(center, element, new Cesium.Cartesian3());
                });
                center = Cesium.Cartesian3.divideByScalar(center, 1 / positions.length, new Cesium.Cartesian3());
                return center;
            }

            const getRangeTexture = (positions) => {
                let result = [], center = new Cesium.Cartesian3();
                positions.forEach(element => {
                    result = result.concat([element.x, element.y, element.z])
                });

                const rangePositionECTexture = new Cesium.Texture({
                    context: viewer.scene.context,
                    pixelFormat: Cesium.PixelFormat.RGB,
                    pixelDatatype: Cesium.PixelDatatype.FLOAT,
                    source: {
                        arrayBufferView: new Float32Array(result),
                        width: positions.length,
                        height: 1,
                    },
                    flipY: false,
                    sampler: {
                        // 使用NEAREST过滤，避免插值
                        minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
                        magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST,
                        // wrapS和wrapT是： 控制纹理在S方向(水平/X方向)【T方向(垂直/Y方向)】的环绕模式
                        // 即：表示当纹理坐标超出[0,1]范围时，纹理采样器(Sampler)中控制纹理坐标超出[0,1]范围时如何处理的参数
                        //   REPEAT: 纹理会重复
                        //   MIRRORED_REPEAT: 纹理会镜像重复
                        //   CLAMP_TO_EDGE会使用最靠近边缘的纹素(texel)值 【对于数据纹理而非视觉纹理，CLAMP_TO_EDGE很重要】
                        //       即：尝试访问纹理坐标小于0的位置，将返回纹理第一行/列的值，坐标大于1的位置，将返回纹理最后一行/列的值
                        //          防止在读取纹理边缘数据时出现意外的采样行为，确保当计算的纹理坐标略微超出边界时仍能获得正确的数据
                        wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
                        wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE
                    }
                })

                return rangePositionECTexture;
            }

            const getPositionWCByDepth_GLSL = () => {
                return `
                    vec4 getPositionWCByDepth(sampler2D depthTexture, vec2 texCoord) {
                        vec4 positionEC = czm_windowToEyeCoordinates(
                            gl_FragCoord.xy,
                            czm_unpackDepth(texture(depthTexture, texCoord))
                        );
                        positionEC = positionEC / positionEC.w;
                        vec4 positionWC = czm_inverseView * positionEC;
                        positionWC = positionWC / positionWC.w;
                        return positionWC;
                    }
                `
            }

            const readRangeTexture_GLSL = (rangePositionsLength) => {
                return `
                     const int rangeLength = ${rangePositionsLength};
                     vec3 _rangePositions[rangeLength];

                     vec3[rangeLength] readRangeTexture(sampler2D _rangeTexture,  vec3[rangeLength] _rangePositions) {
                        for (int i = 0; i < rangeLength; i++) {
                            float xOffset = float(i) + 0.5;
                            float perVal = 1.0 / float(rangeLength);

                            _rangePositions[i] = texture(
                                _rangeTexture,
                                vec2(perVal * xOffset, 0.5)
                            ).xyz;
                        }
                        return _rangePositions;
                    }

              `
            }

            const rangePositionECTexture = getRangeTexture(rangePositions);
            const inverseENU = Cesium.Matrix4.inverse(
                Cesium.Transforms.eastNorthUpToFixedFrame(getRangeCenter(rangePositions)),
                new Cesium.Matrix4()
            );
            const postProcessStages = viewer.scene.postProcessStages.add(
                new Cesium.PostProcessStage({
                    name: 'rangeTexture',
                    fragmentShader: `
                        uniform sampler2D colorTexture;
                        uniform sampler2D depthTexture;
                        in vec2 v_textureCoordinates;


                        uniform sampler2D u_rangeTexture; // 范围纹理
                        uniform mat4 u_inverseENU;  // ENU坐标系的逆矩阵

                        ${getPositionWCByDepth_GLSL()}
                        ${readRangeTexture_GLSL(rangePositions.length)}

                        void main() {
                            vec4 originalColor = texture(colorTexture, v_textureCoordinates);
                            vec4 positionWC = getPositionWCByDepth(depthTexture, v_textureCoordinates);

                            // 读取纹理数据
                            vec3[] rangePositions = readRangeTexture(u_rangeTexture, _rangePositions);

                            // 测试数据读取与原始数据是否一致
                            if (
                                rangePositions[0].x == -2712542.2347164466 &&
                                rangePositions[0].x == -2712542.2347164466 &&
                                rangePositions[0].y == 4291905.330727653 &&
                                rangePositions[0].z == 3847403.3661934948 &&

                                rangePositions[1].x == -2727357.3523860485 &&
                                rangePositions[1].y == 4281552.533897097 &&
                                rangePositions[1].z == 3848462.905365525 &&

                                rangePositions[2].x == -2732460.8527903804 &&
                                rangePositions[2].y == 4288118.765704473 &&
                                rangePositions[2].z == 3837584.939264291 &&

                                rangePositions[3].x == -2716256.053677195 &&
                                rangePositions[3].y == 4298864.491220042 &&
                                rangePositions[3].z == 3837072.97189279
                            ) {
                                out_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
                            } else {
                                out_FragColor = vec4(originalColor.rgb, 1.0);
                            }
                        }
                    `,
                    uniforms: {
                        u_rangeTexture: () => rangePositionECTexture,
                        u_inverseENU: () => inverseENU
                    }
                })
            )

        }

        // 拾取
        // const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
        // handler.setInputAction(function (click) {
        //     const position = viewer.scene.pickPosition(click.position);
        //     if (Cesium.defined(position)) {
        //         console.log(position);
        //     }
        // }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    </script>
</body>

</html>
