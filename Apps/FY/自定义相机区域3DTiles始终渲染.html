<!doctype html>
<html lang="en">
    <head>
        <!-- Use correct character set. -->
        <meta charset="utf-8" />
        <!-- Tell IE to use the latest, best version. -->
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
        />
        <title>è‡ªå®šä¹‰ç›¸æœºé¢å¤–æ¸²æŸ“</title>
    </head>

    <body>
        <div id="cesiumContainer"></div>
        <canvas id="outputCanvas"></canvas>

        <!-- base -->
        <script src="https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.min.js"></script>
        <link rel="stylesheet" href="./common/base.css" />
        <script src="../../Build/CesiumUnminified/Cesium.js"></script>
        <script src="common/methods.js"></script>
        <!-- base end -->

        <script>
            const {
                Cartesian3,
                Cesium3DTileset,
                Cesium3DTilePassState,
                Cesium3DTilePass,
            } = Cesium;

            const viewer = new Cesium.Viewer("cesiumContainer");
            viewer.scene.globe.depthTestAgainstTerrain = true;

            let tileset
            addTileset().then(res => tileset = res)

            // åˆ›å»ºFBO
            const fbo = createFrameBuffer(viewer.scene.context);
            // åˆ›å»ºè‡ªå®šä¹‰ç›¸æœº
            const createOffscreenCamera = (position) => {
                const offscreenCamera = new Cesium.Camera(viewer.scene);
                // è®¾ç½®ä½ç½®åŠæœå‘
                offscreenCamera.setView({
                    destination: position,
                    orientation: new Cesium.HeadingPitchRoll(
                        0,
                        -Cesium.Math.PI_OVER_TWO,
                        0,
                    ),
                });
                // è®¾ç½®è§†é”¥ä½“
                offscreenCamera.frustum = new Cesium.OrthographicFrustum({
                    width: 150,
                    aspectRatio: 1,
                    near: 0.1,
                    far: 200 * 2.0,
                });

                //å¯è§†åŒ–ç›¸æœº
                viewer.scene.primitives.add(
                    new Cesium.DebugCameraPrimitive({
                        camera: offscreenCamera,
                        updateOnChange: false, //ä¸æ›´æ–°
                        show: true,
                    }),
                );

                return offscreenCamera;
            };
            const position = Cartesian3.fromDegrees(116.3915, 39.907, 200);
            const offscreenCamera = createOffscreenCamera(position);

            // åœ¨åœºæ™¯æ¸²æŸ“å‰
            viewer.scene.preRender.addEventListener((scene) => {
                const frameState = scene._frameState;
                const context = scene.context;
                const passState = scene._defaultView.passState;
                // ğŸ†‘ï¼šæ¸…é™¤çš„ç›®çš„åœ¨äºé˜²æ­¢å…¶ä»–çš„å†…å®¹å½±å“åˆ°å•ç‹¬å¯¹3dTilesçš„æŒä¹…åŒ–æ˜¾ç¤º
                frameState.commandList = [];
                context.uniformState._ellipsoid = frameState.mapProjection.ellipsoid;
                context.uniformState.updateCamera(offscreenCamera);
                if (tileset) {
                    // â€¼ï¸ é‡ç‚¹
                    frameState.tilesetPassState = new Cesium3DTilePassState({
                        pass: Cesium3DTilePass.RENDER,
                        camera: offscreenCamera,
                        cullingVolume:
                            offscreenCamera.frustum.computeCullingVolume(
                                offscreenCamera.positionWC,
                                offscreenCamera.directionWC,
                                offscreenCamera.upWC,
                            ),
                        commandList: frameState.commandList,
                    });
                    // æ›´æ–°æ”¶é›†commands ï¼ˆå…¨é‡æ›´æ–°ï¼Œå¦‚æœåªéœ€è¦æŸä¸ªéƒ¨ä»¶ï¼Œåˆ™æŠŠå…¶ä»–éƒ¨ä»¶showè®¾ç½®ï¼Œæœ¬è´¨æ˜¯ç­›é€‰éœ€è¦è¢«æ¸²æŸ“çš„drawCommandï¼‰
                    tileset && tileset.update(frameState);
                    // æ‰§è¡Œ
                    frameState.commandList.forEach((command) => {
                        if (command instanceof Cesium.DrawCommand) {
                            command.execute(context, passState);
                        }
                    });
                    // å¯è§†åŒ–
                    renderFBOToCanvas(viewer, passState.framebuffer);
                }
            });
        </script>
    </body>
</html>
