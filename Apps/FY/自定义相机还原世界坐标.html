<!doctype html>
<html lang="en">

<head>
  <!-- Use correct character set. -->
  <meta charset="utf-8" />
  <!-- Tell IE to use the latest, best version. -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no" />
  <title>Hello World!</title>
</head>

<body>
<div id="cesiumContainer"></div>
<canvas id="outputCanvas"></canvas>
<div id="button-container">
  <button onclick='isRenderToBuffer = true'>开始</button>
  <button onclick="isRenderToBuffer = false">终止</button>
  <button onclick="handleRestoreWorldData()">世界坐标还原读取</button>
</div>

<!-- base -->
<script src="https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.min.js"></script>
<link rel="stylesheet" href="./common/base.css">
<script src="../../Build/CesiumUnminified/Cesium.js"></script>
<script src="common/methods.js"></script>
<!-- base end -->

<script>
  const {Cartesian3, Cartesian4} = Cesium

  const viewer = new Cesium.Viewer("cesiumContainer", {
    // terrain: Cesium.Terrain.fromWorldTerrain(),
  });
  viewer.scene.globe.depthTestAgainstTerrain = true;

  addTileset();

  // 创建FBO
  const fbo = createFrameBuffer(viewer.scene.context);
  const renderDepthFbo = createFrameBuffer(viewer.scene.context)

  const createOffscreenCamera = (position) => {
    const offscreenCamera = new Cesium.Camera(viewer.scene)
    // 设置位置及朝向
    offscreenCamera.setView({
      destination: position,
      orientation: new Cesium.HeadingPitchRoll(0, -Cesium.Math.PI_OVER_TWO, 0)
    });
    // 设置视锥体
    offscreenCamera.frustum = new Cesium.OrthographicFrustum({
      width: 300,
      aspectRatio: 1,
      near: 0.01,
      far: 300 * 2.0
    });

    //可视化相机
    viewer.scene.primitives.add(new Cesium.DebugCameraPrimitive({
      camera: offscreenCamera,
      updateOnChange: false,//不更新
      show: true,
    }));

    return offscreenCamera;
  }
  // 创建自定义相机
  const position = Cartesian3.fromDegrees(116.3915, 39.907, 200);
  const offscreenCamera = createOffscreenCamera(position)
  viewer.scene.camera.flyTo({
    destination: position,
    duration: 2
  })


  let isRenderToBuffer = false
  viewer.scene.postRender.addEventListener(scene => {
    if (isRenderToBuffer && offscreenCamera) {
      const frameState = scene._frameState;
      const context = scene.context;

      const view = scene._defaultView;
      scene._view = view;
      const passState = view.passState;

      const mainFramebuffer = passState.framebuffer;
      // 自定义fbo
      passState.framebuffer = fbo;
      scene._clearColorCommand.execute(context, passState)
      scene._depthClearCommand.execute(context, passState)

      // 自定义相机
      context.uniformState.updateCamera(offscreenCamera)
      const cullingVolume = offscreenCamera.frustum.computeCullingVolume(
        offscreenCamera.positionWC,
        offscreenCamera.directionWC,
        offscreenCamera.upWC
      );

      const frustumCommandsList = view.frustumCommandsList;
      const numFrustums = frustumCommandsList.length;

      function performPass(frustumCommands, passId) {
        context.uniformState.updatePass(passId);
        const commands = frustumCommands.commands[passId];
        const commandCount = frustumCommands.indices[passId];
        for (let j = 0; j < commandCount; ++j) {
          if (cullingVolume.computeVisibility(commands[j].boundingVolume) !== Cesium.Intersect.OUTSIDE) {
            commands[j].execute(context, passState)
          }
        }
        return commandCount;
      }

      // Execute commands in each frustum in back to front order
      for (let i = 0; i < numFrustums; ++i) {
        const index = numFrustums - i - 1;
        const frustumCommands = frustumCommandsList[index];

        performPass(frustumCommands, Cesium.Pass.GLOBE);
        performPass(frustumCommands, Cesium.Pass.CESIUM_3D_TILE);
      }

      // reset && release
      passState.framebuffer = mainFramebuffer;

      // 可视化
      renderFBOToCanvas(viewer, fbo)
      // 深度读取
      const renderDepthCommand = context.createViewportQuadCommand(
        `
           in vec2 v_textureCoordinates;
           uniform sampler2D u_depthTexture;

           void main() {
             float depth = czm_unpackDepth(texture(u_depthTexture, v_textureCoordinates));
             out_FragColor = vec4(gl_FragCoord.xy / czm_viewport.zw, depth, 1.0);
           }
        `,
        {
          framebuffer: renderDepthFbo,
          uniformMap: {
            u_depthTexture: () => fbo.depthTexture,
          },
        },
      );
      renderDepthCommand.execute(context, passState);
    }
  })


  // 世界坐标还原可视化
  const pointCollection = new Cesium.PointPrimitiveCollection();
  viewer.scene.primitives.add(pointCollection);
  const handleRestoreWorldData = () => {
    isRenderToBuffer = false

    const context = viewer.scene.context
    const width = context.canvas.clientWidth;
    const height = context.canvas.clientHeight;
    const pixelsData = context.readPixels({
      x: 0,
      y: 0,
      width,
      height,
      framebuffer: renderDepthFbo,
    });
    const vec4PixelData = Cartesian4.unpackArray(pixelsData).map((pixel) => {
      // PixelDatatype.UNSIGNED_BYTE归一化的影响
      return Cartesian4.divideByScalar(pixel, 255.0, pixel)
    })
    console.log(vec4PixelData)


    const ray = new Cesium.Ray(offscreenCamera.position, offscreenCamera.direction)
    const samplerSize = 10
    const worldPositions = []
    for (let i = 0; i < height; i+=samplerSize) {
      for (let j = 0; j < width; j+=samplerSize) {
        // xyz为遵循frustum下的线性值，范围 0-1
        const {x,y,z} = vec4PixelData[i * width + j]
        const {left, right, top, bottom, near, far} = offscreenCamera.frustum.offCenterFrustum

        const xLocal = Number(left) + x * (right - left)
        const yLocal = Number(bottom) + y * (top - bottom)

        const offset = new Cartesian3()
        Cartesian3.multiplyByScalar(offscreenCamera.right,  xLocal, offset)
        Cartesian3.add(offset, Cartesian3.multiplyByScalar(offscreenCamera.up,  yLocal, new Cartesian3()), offset)
        Cartesian3.add(offscreenCamera.position, offset, offset)

        const distance = near + z * (far - near)
        const cloneRay = Cesium.Ray.clone(ray)

        // 相机偏移后进行世界坐标点的获取
        cloneRay.origin = offset
        worldPositions.push(Cesium.Ray.getPoint(cloneRay, distance))
      }
    }

    pointCollection.removeAll()
    worldPositions.forEach((position) => {
      pointCollection.add({
        position,
        color: Cesium.Color.YELLOW, // 点颜色
        pixelSize: 5, // 像素大小
        outlineColor: Cesium.Color.RED, // 边框颜色
        outlineWidth: 2 // 边框宽度
      });
    })
  }
</script>
</body>

</html>
